var documenterSearchIndex = {"docs":
[{"location":"generated/literate_example/","page":"Code Example","title":"Code Example","text":"EditURL = \"../../literate/literate_example.jl\"","category":"page"},{"location":"generated/literate_example/#Code-Example","page":"Code Example","title":"Code Example","text":"","category":"section"},{"location":"generated/literate_example/","page":"Code Example","title":"Code Example","text":"using DiagrammaticEquations","category":"page"},{"location":"api/#Library-Reference","page":"Library Reference","title":"Library Reference","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"Modules = [DiagrammaticEquations, DiagrammaticEquations.Deca, DiagrammaticEquations.Learn]","category":"page"},{"location":"api/#DiagrammaticEquations.DiagrammaticEquations","page":"Library Reference","title":"DiagrammaticEquations.DiagrammaticEquations","text":"Some description of ths package\n\n\n\n\n\n","category":"module"},{"location":"api/#Catlab.WiringDiagrams.WiringDiagramAlgebras.oapply-Union{Tuple{D}, Tuple{Catlab.Programs.RelationalPrograms.RelationDiagram, Vector{D}}} where D<:(Catlab.CategoricalAlgebra.StructuredCospans.StructuredMulticospan{Catlab.CategoricalAlgebra.StructuredCospans.DiscreteACSet{ACSets.DenseACSets.AnonACSet{ACSets.Schemas.TypeLevelBasicSchema{Symbol, Tuple{:Var}, Tuple{}, Tuple{:Type, :Operator, :Name}, Tuple{(:type, :Var, :Type), (:name, :Var, :Name)}}, Tuple{Type, Operator, Name}, NamedTuple{(:Var, :Type, :Operator, :Name), NTuple{4, ACSets.DenseACSets.IntParts}}, NamedTuple{(:type, :name), Tuple{ACSets.ColumnImplementations.DenseColumn{Union{ACSets.ColumnImplementations.AttrVar, Type}, Array{Union{ACSets.ColumnImplementations.AttrVar, Type}, 1}}, ACSets.ColumnImplementations.DenseColumn{Union{ACSets.ColumnImplementations.AttrVar, Name}, Array{Union{ACSets.ColumnImplementations.AttrVar, Name}, 1}}}}, ACSets.DenseACSets.IntParts}, SummationDecapode{Type, Operator, Name}}} where {Type, Operator, Name})","page":"Library Reference","title":"Catlab.WiringDiagrams.WiringDiagramAlgebras.oapply","text":"function oapply(relation::RelationDiagram, podes::Vector{D}) where {D<:OpenSummationDecapode}\n\nCompose a list of Decapodes as specified by the given relation diagram.\n\nThe Decapodes must be given in the same order as they were specified in the relation.\n\nState variables (such as the (C,V) given in the head of the following @relation) do not affect the result of a composition.\n\nExamples\n\njulia> compose_diff_adv = @relation (C,V) begin\n  diffusion(C, ϕ₁)\n  advection(C, ϕ₂, V)\n  superposition(ϕ₁, ϕ₂, ϕ, C)\nend;\n\njulia> oapply(compose_diff_adv, [(Diffusion, [:C, :ϕ]),\n  (Advection, [:C, :ϕ, :V]), (Superposition, [:ϕ₁, :ϕ₂, :ϕ, :C])]);\n\n\n\n\n\n","category":"method"},{"location":"api/#DiagrammaticEquations.Open-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{SummationDecapode{T, U, V}, AbstractVector{Symbol}}} where {T, U, V}","page":"Library Reference","title":"DiagrammaticEquations.Open","text":"Open(d::SummationDecapode{T,U,V}, names::AbstractVector{Symbol}) where {T,U,V}\n\ncreates an OpenSummationDecapode based on named variables rather than variable indices.  See AlgebraicPetri.jl's Open for the analogous verion for LabelledReactionNetworks.\n\n\n\n\n\n","category":"method"},{"location":"api/#DiagrammaticEquations.average_rewrite-Tuple{SummationDecapode}","page":"Library Reference","title":"DiagrammaticEquations.average_rewrite","text":"function average_rewrite(deca_source::SummationDecapode)\n\nCompute each quantitity in the given Decapode by the average of all computation paths leading to that node.\n\n\n\n\n\n","category":"method"},{"location":"api/#DiagrammaticEquations.collate-NTuple{4, Any}","page":"Library Reference","title":"DiagrammaticEquations.collate","text":"function collate(equations, boundaries, uwd, symbols)\n\nCreate a collage of two Decapodes that simulates with boundary conditions. ```\n\n\n\n\n\n","category":"method"},{"location":"api/#DiagrammaticEquations.contract_operators-Tuple{SummationDecapode}","page":"Library Reference","title":"DiagrammaticEquations.contract_operators","text":"function contract_operators(d::SummationDecapode)\n\nFind chains of Op1s in the given Decapode, and replace them with a single Op1 with a vector of function names. After this process, all Vars that are not a part of any computation are removed.\n\n\n\n\n\n","category":"method"},{"location":"api/#DiagrammaticEquations.dot_rename!-Tuple{AbstractNamedDecapode}","page":"Library Reference","title":"DiagrammaticEquations.dot_rename!","text":"dot_rename!(d::AbstractNamedDecapode)\n\nRename tangent variables by their depending variable appended with a dot. e.g. If D == ∂ₜ(C), then rename D to Ċ.\n\nIf a tangent variable updates multiple vars, choose one arbitrarily. e.g. If D == ∂ₜ(C) and D == ∂ₜ(B), then rename D to either Ċ or B ̇.\n\n\n\n\n\n","category":"method"},{"location":"api/#DiagrammaticEquations.expand_operators-Tuple{SummationDecapode}","page":"Library Reference","title":"DiagrammaticEquations.expand_operators","text":"function expand_operators(d::SummationDecapode)\n\nFind operations that are compositions, and expand them with intermediate variables.\n\n\n\n\n\n","category":"method"},{"location":"api/#DiagrammaticEquations.fill_names!-Tuple{AbstractNamedDecapode}","page":"Library Reference","title":"DiagrammaticEquations.fill_names!","text":"fill_names!(d::AbstractNamedDecapode)\n\nProvide a variable name to all the variables that don't have names.\n\n\n\n\n\n","category":"method"},{"location":"api/#DiagrammaticEquations.find_dep_and_order-Tuple{AbstractNamedDecapode}","page":"Library Reference","title":"DiagrammaticEquations.find_dep_and_order","text":"find_dep_and_order(d::AbstractNamedDecapode)\n\nFind the order of each tangent variable in the Decapode, and the index of the variable that it is dependent on. Returns a tuple of (dep, order), both of which respecting the order in which incident(d, :∂ₜ, :op1) returns Vars.\n\n\n\n\n\n","category":"method"},{"location":"api/#DiagrammaticEquations.infer_types!-Tuple{SummationDecapode, Vector{NamedTuple{(:src_type, :tgt_type, :op_names), Tuple{Symbol, Symbol, Vector{Symbol}}}}, Vector{NamedTuple{(:proj1_type, :proj2_type, :res_type, :op_names), Tuple{Symbol, Symbol, Symbol, Vector{Symbol}}}}}","page":"Library Reference","title":"DiagrammaticEquations.infer_types!","text":"function infer_types!(d::SummationDecapode, op1_rules::Vector{NamedTuple{(:src_type, :tgt_type, :replacement_type, :op), NTuple{4, Symbol}}})\n\nInfer types of Vars given rules wherein one type is known and the other not.\n\n\n\n\n\n","category":"method"},{"location":"api/#DiagrammaticEquations.remove_neighborless_vars!-Tuple{SummationDecapode}","page":"Library Reference","title":"DiagrammaticEquations.remove_neighborless_vars!","text":"function remove_neighborless_vars!(d::SummationDecapode)\n\nRemove all Vars from the given Decapode that are not part of any computation.\n\n\n\n\n\n","category":"method"},{"location":"api/#DiagrammaticEquations.resolve_overloads!-Tuple{SummationDecapode, Vector{NamedTuple{(:src_type, :tgt_type, :resolved_name, :op), NTuple{4, Symbol}}}, Vector{NamedTuple{(:proj1_type, :proj2_type, :res_type, :resolved_name, :op), NTuple{5, Symbol}}}}","page":"Library Reference","title":"DiagrammaticEquations.resolve_overloads!","text":"function resolve_overloads!(d::SummationDecapode, op1_rules::Vector{NamedTuple{(:src_type, :tgt_type, :resolved_name, :op), NTuple{4, Symbol}}})\n\nResolve function overloads based on types of src and tgt.\n\n\n\n\n\n","category":"method"},{"location":"api/#DiagrammaticEquations.type_check_Decapodes_composition-Union{Tuple{D}, Tuple{Catlab.Programs.RelationalPrograms.RelationDiagram, Vector{D}}} where D<:(Catlab.CategoricalAlgebra.StructuredCospans.StructuredMulticospan{Catlab.CategoricalAlgebra.StructuredCospans.DiscreteACSet{ACSets.DenseACSets.AnonACSet{ACSets.Schemas.TypeLevelBasicSchema{Symbol, Tuple{:Var}, Tuple{}, Tuple{:Type, :Operator, :Name}, Tuple{(:type, :Var, :Type), (:name, :Var, :Name)}}, Tuple{Type, Operator, Name}, NamedTuple{(:Var, :Type, :Operator, :Name), NTuple{4, ACSets.DenseACSets.IntParts}}, NamedTuple{(:type, :name), Tuple{ACSets.ColumnImplementations.DenseColumn{Union{ACSets.ColumnImplementations.AttrVar, Type}, Array{Union{ACSets.ColumnImplementations.AttrVar, Type}, 1}}, ACSets.ColumnImplementations.DenseColumn{Union{ACSets.ColumnImplementations.AttrVar, Name}, Array{Union{ACSets.ColumnImplementations.AttrVar, Name}, 1}}}}, ACSets.DenseACSets.IntParts}, SummationDecapode{Type, Operator, Name}}} where {Type, Operator, Name})","page":"Library Reference","title":"DiagrammaticEquations.type_check_Decapodes_composition","text":"function type_check_Decapodes_composition(relation::RelationDiagram, decs::Vector{OpenSummationDecapode})\n\nCheck that the types of all Vars connected by the same junction match.\n\nThis function only throws an error on the first type mismatch found.\n\n\n\n\n\n","category":"method"},{"location":"api/#DiagrammaticEquations.unique_by!-Tuple{Any, Symbol, Vector{Symbol}}","page":"Library Reference","title":"DiagrammaticEquations.unique_by!","text":"function unique_by!(acset, column_names::Vector{Symbol})\n\nGiven column names from the same table, remove duplicate rows.\n\nWARNING: This function does not check if other tables index into the one given. Removal of rows is performed with prejudice.\n\nSee also: unique_by.\n\nExamples\n\njulia> unique_by!(parallel_arrows(Graph, 123), :E, [:src,:tgt]) == parallel_arrows(Graph, 1)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"api/#DiagrammaticEquations.unique_by-Tuple{Any, Symbol, Vector{Symbol}}","page":"Library Reference","title":"DiagrammaticEquations.unique_by","text":"function unique_by(acset, column_names::Vector{Symbol})\n\nGiven column names from the same table, return a copy of the acset with duplicate rows removed. Removal of rows is performed with prejudice.\n\nWARNING: This function does not check if other tables index into the one given. Removal of rows is performed with prejudice.\n\nSee also: unique_by!.\n\nExamples\n\njulia> unique_by(parallel_arrows(Graph, 123), :E, [:src,:tgt]) == parallel_arrows(Graph, 1)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"api/#DiagrammaticEquations.@decapode-Tuple{Any}","page":"Library Reference","title":"DiagrammaticEquations.@decapode","text":"macro Decapode(e)\n\nConstruct a Decapode.\n\n\n\n\n\n","category":"macro"},{"location":"api/#DiagrammaticEquations.Deca.op1_inf_rules_1D","page":"Library Reference","title":"DiagrammaticEquations.Deca.op1_inf_rules_1D","text":"These are the default rules used to do type inference in the 1D exterior calculus.\n\n\n\n\n\n","category":"constant"},{"location":"api/#DiagrammaticEquations.Deca.op1_inf_rules_2D","page":"Library Reference","title":"DiagrammaticEquations.Deca.op1_inf_rules_2D","text":"These are the default rules used to do type inference in the 2D exterior calculus.\n\n\n\n\n\n","category":"constant"},{"location":"api/#DiagrammaticEquations.Deca.op1_res_rules_1D","page":"Library Reference","title":"DiagrammaticEquations.Deca.op1_res_rules_1D","text":"These are the default rules used to do function resolution in the 1D exterior calculus.\n\n\n\n\n\n","category":"constant"},{"location":"api/#DiagrammaticEquations.Deca.op1_res_rules_2D","page":"Library Reference","title":"DiagrammaticEquations.Deca.op1_res_rules_2D","text":"These are the default rules used to do function resolution in the 2D exterior calculus.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Catlab.Graphics.GraphvizGraphs.to_graphviz-Tuple{AbstractDecapode}","page":"Library Reference","title":"Catlab.Graphics.GraphvizGraphs.to_graphviz","text":"Graphics.to_graphviz(F::AbstractDecapode; directed = true, kw...)\n\nVisualize the given Decapode through Graphviz. Ensure that you have called using Catlab.Graphics before-hand, and have a way of visualizing SVG files in your current environment.\n\n\n\n\n\n","category":"method"},{"location":"api/#DiagrammaticEquations.Deca.recursive_delete_parents-Tuple{SummationDecapode, Vector{Int64}}","page":"Library Reference","title":"DiagrammaticEquations.Deca.recursive_delete_parents","text":"function recursive_delete_parents!(d::SummationDecapode, to_delete::Vector{Int64})\n\nDelete the given nodes and their parents in the Decapode, recursively.\n\n\n\n\n\n","category":"method"},{"location":"api/#DiagrammaticEquations.Deca.unicode!-Tuple{SummationDecapode}","page":"Library Reference","title":"DiagrammaticEquations.Deca.unicode!","text":"function unicode!(d::SummationDecapode)\n\nReplace ASCII operators with their Unicode equivalents.\n\n\n\n\n\n","category":"method"},{"location":"api/#DiagrammaticEquations.Deca.vec_to_dec!-Tuple{SummationDecapode}","page":"Library Reference","title":"DiagrammaticEquations.Deca.vec_to_dec!","text":"function vec_to_dec!(d::SummationDecapode)\n\nReplace Vector Calculus operators with Discrete Exterior Calculus equivalents.\n\n\n\n\n\n","category":"method"},{"location":"api/#DiagrammaticEquations.resolve_overloads!-Tuple{SummationDecapode}","page":"Library Reference","title":"DiagrammaticEquations.resolve_overloads!","text":"function resolve_overloads!(d::SummationDecapode)\n\nResolve function overloads based on types of src and tgt.\n\n\n\n\n\n","category":"method"},{"location":"#DiagrammaticEquations.jl","page":"DiagrammaticEquations.jl","title":"DiagrammaticEquations.jl","text":"","category":"section"},{"location":"","page":"DiagrammaticEquations.jl","title":"DiagrammaticEquations.jl","text":"CurrentModule = DiagrammaticEquations","category":"page"},{"location":"","page":"DiagrammaticEquations.jl","title":"DiagrammaticEquations.jl","text":"DiagrammaticEquations.jl is a Julia library implementing category-theoretic formally reasoning about systems of algebraic and differential equations with diagrams. ","category":"page"}]
}
